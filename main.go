package main

import (
	"flag"
	"path"
	"strings"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/reflect/protoreflect"
)

const (
	mcpServerPackage = protogen.GoImportPath("github.com/mark3labs/mcp-go/server")
	mcpPackage       = protogen.GoImportPath("github.com/mark3labs/mcp-go/mcp")
	contextPackage   = protogen.GoImportPath("context")
	jsonPackage      = protogen.GoImportPath("encoding/json")
)

func main() {
	var flags flag.FlagSet

	goPackageName := flags.String("go_package_name", "", "")
	goModuleName := flags.String("go_module_name", "", "")

	opts := protogen.Options{
		ParamFunc: flags.Set,
	}

	opts.Run(func(gen *protogen.Plugin) error {
		for _, f := range gen.Files {
			if !f.Generate {
				continue
			}
			if err := generateFile(gen, f, *goPackageName, *goModuleName); err != nil {
				gen.Error(err)
			}
		}
		return nil
	})
}

func generateFile(gen *protogen.Plugin, file *protogen.File, goPackageName, goModuleName string) error {
	if len(file.Services) == 0 {
		return nil
	}

	for _, service := range file.Services {
		serviceBaseName := strings.ToLower(service.GoName)
		if strings.HasSuffix(serviceBaseName, "interface") {
			serviceBaseName = strings.TrimSuffix(serviceBaseName, "interface")
		} else if strings.HasSuffix(serviceBaseName, "service") {
			serviceBaseName = strings.TrimSuffix(serviceBaseName, "service")
		}
		if serviceBaseName == "" {
			serviceBaseName = strings.ToLower(service.GoName)
		}

		// protoDir := goModuleName + "/" +path.Dir(path.Dir(file.Desc.Path())) + "/" string(file.GoPackageName)
		// filename := strings.TrimSuffix(protoDir, ".proto") + "_mcp.go"
		g := gen.NewGeneratedFile(serviceBaseName+"_mcp.go", file.GoImportPath)

		g.P("// Code generated by protoc-gen-mcpgo. DO NOT EDIT.")
		g.P("// source: ", file.Desc.Path())
		g.P()
		// g.P("package ", file.GoPackageName)
		g.P("package ", goPackageName)
		g.P()

		importPath := goModuleName + "/" + path.Dir(path.Dir(file.Desc.Path())) + "/" + string(file.GoPackageName)
		g.P("import (")
		g.P("	", protogen.GoImportPath(importPath))
		g.P(")")
		g.P()

		generateServiceStruct(g, service)
		generateConstructor(g, service)
		generateMcpSetupMethod(g, service)
		for _, method := range service.Methods {
			if shouldSkipMethod(method) {
				continue
			}
			generateRpcHandler(g, service, method, string(file.GoPackageName))
		}
	}
	return nil
}

func shouldSkipMethod(method *protogen.Method) bool {
	comments := method.Comments.Leading.String() + method.Comments.Trailing.String()
	return strings.Contains(comments, "@mcp: reject")
}

func generateServiceStruct(g *protogen.GeneratedFile, service *protogen.Service) {
	g.P("type ", service.GoName, "McpService struct {")
	g.P("	", service.GoName, " ", service.GoName)
	g.P("}")
	g.P()
}

func generateConstructor(g *protogen.GeneratedFile, service *protogen.Service) {
	structName := service.GoName + "McpService"
	paramName := strings.ToLower(service.GoName[:1]) + service.GoName[1:]
	// paramType := protogen.GoImportPath(protoGoPackageName).Ident(service.GoName)

	g.P("func New", structName, "(", paramName, " ", service.GoName, ") *", structName, " {")
	g.P("	return &", structName, "{")
	g.P("		", service.GoName, ": ", paramName, ",")
	g.P("	}")
	g.P("}")
	g.P()
}

func generateMcpSetupMethod(g *protogen.GeneratedFile, service *protogen.Service) {
	methodName := strings.ReplaceAll(service.GoName, "Interface", "")
	if methodName == "" {
		methodName = service.GoName
	}
	methodName += "Mcp"

	receiver := strings.ToLower(service.GoName[:1])
	structName := service.GoName + "McpService"

	g.P("func (", receiver, " *", structName, ") ", methodName, "() (*", mcpServerPackage.Ident("MCPServer"), ", error) {")
	g.P("	ser := ", mcpServerPackage.Ident("NewMCPServer"), `("`, service.GoName, `", "0.0.1",`)
	g.P("		", mcpServerPackage.Ident("WithToolCapabilities"), "(false), // Assuming default, make configurable if needed")
	g.P("	)")

	for _, method := range service.Methods {
		if shouldSkipMethod(method) {
			continue
		}

		rpcName := method.GoName
		methodComments := getComments(method.Comments.Leading)

		g.P()
		g.P("	// Add tool for ", rpcName)
		g.P("	tool_", rpcName, " := ", mcpPackage.Ident("NewTool"), `("`, rpcName, `",`)
		if methodComments != "" {
			g.P("		", mcpPackage.Ident("WithDescription"), `("`, escapeString(methodComments), `"),`)
		}

		for _, field := range method.Input.Fields {
			mcpParamName := field.Desc.JSONName()
			if mcpParamName == "" {
				mcpParamName = string(field.Desc.Name())
			}

			fieldCommentsText := getComments(field.Comments.Leading)
			isRequired := strings.Contains(field.Comments.Leading.String(), "@mcp: required")

			mcpTypeMethod := ""
			switch field.Desc.Kind() {
			case protoreflect.StringKind:
				mcpTypeMethod = "WithString"
			case protoreflect.Int32Kind,
				protoreflect.DoubleKind,
				protoreflect.Int64Kind,
				protoreflect.Fixed32Kind:
				mcpTypeMethod = "WithNumber"
			case protoreflect.BoolKind:
				mcpTypeMethod = "WithBoolean"
			default:
				g.P("		// TODO: Unsupported field type for MCP: ", field.Desc.Kind(), " for field ", field.GoName)
				continue
			}

			g.P("		", mcpPackage.Ident(mcpTypeMethod), `("`, mcpParamName, `",`)
			if fieldCommentsText != "" {
				g.P("			", mcpPackage.Ident("Description"), `("`, escapeString(fieldCommentsText), `"),`)
			}
			if isRequired {
				g.P("			", mcpPackage.Ident("Required"), "(),")
			}
			g.P("		), // Close ", mcpTypeMethod)
		}
		g.P("	) // Close NewTool")
		g.P("	ser.AddTool(tool_", rpcName, ", ", receiver, ".", rpcName, ")")
	}
	g.P()
	g.P("	return ser, nil")
	g.P("}")
	g.P()
}

func generateRpcHandler(g *protogen.GeneratedFile, service *protogen.Service, method *protogen.Method, goPackage string) {
	receiver := strings.ToLower(service.GoName[:1])
	structName := service.GoName + "McpService"
	rpcName := method.GoName
	requestType := method.Input.GoIdent

	g.P("func (", receiver, " *", structName, ") ", rpcName, "(ctx ", contextPackage.Ident("Context"), ", request ", mcpPackage.Ident("CallToolRequest"), ") (*", mcpPackage.Ident("CallToolResult"), ", error) {")
	g.P("	args := request.GetRawArguments()")
	g.P("	jsonByte, err := ", jsonPackage.Ident("Marshal"), "(args)")
	g.P("	if err != nil {")
	g.P("		return nil, err")
	g.P("	}")
	g.P()
	argsVarName := "requestArgs"
	g.P("	var ", argsVarName, " ", goPackage, ".", requestType.GoName)
	g.P("	err = ", jsonPackage.Ident("Unmarshal"), "(jsonByte, &", argsVarName, ")")
	g.P("	if err != nil {")
	g.P("		return nil, err")
	g.P("	}")
	g.P()
	g.P("	res, err := ", receiver, ".", service.GoName, ".", rpcName, "(ctx, &", argsVarName, ")")
	g.P("	if err != nil {")
	g.P("		return nil, err")
	g.P("	}")
	g.P()
	g.P("	resJson, err := ", jsonPackage.Ident("Marshal"), "(&res)") // Marshal the response struct pointer
	g.P("	if err != nil {")
	g.P("		return nil, err")
	g.P("	}")
	g.P("	return ", mcpPackage.Ident("NewToolResultText"), "(string(resJson)), nil")
	g.P("}")
	g.P()
}

func getComments(rawComments protogen.Comments) string {
	commentStr := rawComments.String()
	if commentStr == "" {
		return ""
	}
	var lines []string
	for _, line := range strings.Split(strings.TrimSpace(commentStr), "\n") {
		trimmedLine := strings.TrimSpace(line)
		trimmedLine = strings.TrimPrefix(trimmedLine, "//")
		trimmedLine = strings.TrimPrefix(trimmedLine, "/*")
		trimmedLine = strings.TrimPrefix(trimmedLine, "*") // Handle lines in '/* ... */' blocks
		trimmedLine = strings.TrimSuffix(trimmedLine, "*/")
		trimmedLine = strings.TrimSpace(trimmedLine)

		if !strings.HasPrefix(trimmedLine, "@mcp:") {
			lines = append(lines, trimmedLine)
		}
	}
	var finalLines []string
	for _, line := range lines {
		if line != "" {
			finalLines = append(finalLines, line)
		}
	}
	return strings.Join(finalLines, " ")
}

func escapeString(s string) string {
	s = strings.ReplaceAll(s, `\`, `\\`)
	s = strings.ReplaceAll(s, `"`, `\"`)
	return s
}
